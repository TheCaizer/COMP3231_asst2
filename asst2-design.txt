The design we're going for was the implement an array of global open file table 
with the struct:
struct{
    int Flag; // The flag for the opened file
    struct vnode* vnodeptr; // Pointer to the vnode
    off_t Offset; // Number of bytes offset for the opened file 
    int ReferenceCounter; // Number of reference for this file
} OpenFileTable;

The per-process file descriptor would be an array of pointers of pointer to the openfiletable
struct inside of proc struct in proc.h as shown in the Lecture slides. We have
file descriptors in each process in proc.h whose index is the FD.


HOW TO IMPLEMENT THE FUNCTIONS:
open();
We check the filename is valid and if it is invoke vfs_open();

close();
To close a file we have to check if fd is valid, we decrement the reference counter
if it goes to 0 we can close the file if greater than 0 we don't. We retun 0 on success.

read(;
We check the fd is valid and the flag is read or rw. Use uio_kinit to get an uio and pass
into VOP_READ(vnode, uio).

write();
Similar to read we need to check if the fd is valid and then check the flag is write or rw.
Then we use uio_kinit to get an uio then pass it into VOP_WRITE(vnode, uio).

lseek();
We check if the fd is valid, then if it is update the vnode pointer in the fd to 
the offset input either relative to the start, end or current position in the file
depending on the value of whence.

dup2();
We check if fd is a valid one then we check if the newFD is a opened file or not
if it is then we can close the old file and then point to the new file. If it is 
not then we can open the file and then close old and point to new. If new and 
old are the same then we do nothing.